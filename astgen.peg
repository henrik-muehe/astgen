%{
#include <cstdio>
#include <iostream>
#include <ostream>
#include <memory>
#include <vector>
#include <string>

template<typename T, typename ...Args>
std::unique_ptr<T> make_unique( Args&& ...args )
{
    return std::unique_ptr<T>( new T( std::forward<Args>(args)... ) );
}

#include "ast.hpp"

using namespace std;

auto& out = cout;
#define YYSTYPE std::unique_ptr<Ast>

static bool simpleType(std::string tn) {
  return (tn=="bool"||tn=="integer"||tn=="string"||tn=="int64_t");
}

void generateForwards(const std::vector<std::unique_ptr<Node>>& nodes) {
  cout << "// Forward declarations" << endl;
  for (auto& nodePtr : nodes) {
    Node& node=*reinterpret_cast<Node*>(nodePtr.get());    
    out << "struct "<<node.name->id<<";" << endl;
  }
  cout << endl;
}

void generateVisitor(const std::vector<std::unique_ptr<Node>>& nodes) {
  out << "// Visitor base class" << endl;
  out << "struct Visitor {" << endl;
  out << "  virtual void visitPre(const std::string& name,const Ast&) {}" << endl;
  out << "  virtual void visitPost(const std::string& name,const Ast&) {}" << endl;
  out << "  virtual void collectionPre() {}" << endl;
  out << "  virtual void collectionPost() {}" << endl;
  for (auto& nodePtr : nodes) {
    Node& node=*reinterpret_cast<Node*>(nodePtr.get());
    
    out << "  virtual void visitPre(const std::string& name,const "<<node.name->id<<"&) {}" << endl;
    out << "  virtual void visitPost(const std::string& name,const "<<node.name->id<<"&) {}" << endl;
  }
  out << "};" << endl << endl;
}

void generatePrettyPrintVisitor(const std::vector<std::unique_ptr<Node>>& nodes) {
  out << "// Pretty Print Visitor" << endl;
  out << "struct PrettyPrintVisitor : public Visitor {" << endl;
  out << "  std::stack<bool> doIndent;" << endl;
  out << "  void applyIndent() { if (doIndent.top()) { std::cerr << std::string(doIndent.size()*2,' '); } }" << endl;
  out << "  void applyNl() { if (doIndent.top()) { std::cerr << std::endl; } }" << endl;
  out << "  PrettyPrintVisitor() : indent(0) { doIndent.push(false); }" << endl;
  out << "  void collectionPre() { applyIndent(); std::cerr << \"[\" << std::endl; doIndent.push(true); }" << endl;
  out << "  void collectionPost() { doIndent.pop(); std::cerr << std::string(indent,' ') << \"]\" << std::endl; }" << endl;
  for (auto& nodePtr : nodes) {
    Node& node=*reinterpret_cast<Node*>(nodePtr.get());
    
    out << "  virtual void visitPre(const std::string& name,const "<<node.name->id<<"& n) { applyIndent(); std::cerr << \"(\" << name << \":" << node.name->id <<" \"; doIndent.push(false); }" << endl;
    out << "  virtual void visitPost(const std::string& name,const "<<node.name->id<<"& n) { applyIndent(); doIndent.pop(); std::cerr << \")\"; applyNl(); }" << endl;
  }
  out << "};" << endl << endl;
}

void generate(Node& node) {
  // Struct
  out << "struct " << node.name->id << " : public Ast {" << endl;
  for (auto& a : node.attributes) {
    if (simpleType(a->type->id->id)) {
      out << "  " << a->type->id->id << " " << a->name->id << ";" << endl;
    } else if (a->type->collection) {
      out << "  std::vector<std::unique_ptr<" << a->type->id->id << ">> " << a->name->id << ";" << endl;
    } else {
      out << "  std::unique_ptr<" << a->type->id->id << "> " << a->name->id << ";" << endl;
    }
  }

  // Constructor signature
  out << endl;
  out << "  " << node.name->id << "(";
  bool first=true;
  for (auto& a : node.attributes) {      
    if (!first) out << ","; first=false;
    if (simpleType(a->type->id->id)) {
      out << "const "<< a->type->id->id << "& " << a->name->id;
    } else if (!a->type->collection) {
      out << "std::unique_ptr<Ast>&& " << a->name->id;
    } else {
      out << "std::vector<std::unique_ptr<Ast>>&& " << a->name->id;
    }
  }
  out << ") {" << endl;

  // Constructor body
  for (auto& a : node.attributes) {      
    if (simpleType(a->type->id->id)) {
      out << "    " << "this->" << a->name->id << "=" << a->name->id << ";" << endl;
    } else if (!a->type->collection) {
      out << "    " << "this->" << a->name->id << "=std::unique_ptr<" << a->type->id->id << ">(dynamic_cast<" << a->type->id->id << "*>(" << a->name->id << ".get()));" << endl;
      out << "    " << "if (!this->" << a->name->id << ") { std::cerr << \"AST type failure for " << node.name->id << " attribute " << a->name->id << "\" << std::endl; throw; }" << std::endl;
      out << "    " << a->name->id << ".release();" << endl;
      out << endl;
    } else {
      out << "    " << "for (auto& item : " << a->name->id << ") {" << endl;
      out << "      " << "this->" << a->name->id << ".push_back(std::unique_ptr<"<< a->type->id->id <<">(dynamic_cast<"<< a->type->id->id << "*>(item.get())));" << endl;
      out << "      " << "item.release();"<<endl;
      out << "    " << "}"<<endl;
    }
  }    
  out << "  }" << endl << endl;
  
  // Visitor accept
  out << "  " << "void accept(const std::string& name,Visitor& visitor) {" << endl;
  out << "    " << "visitor.visitPre(name,*this);" << endl;
  for (auto& a : node.attributes) {      
    if (simpleType(a->type->id->id)) {
      // We don't visit those right now
    } else if (!a->type->collection) {
      out << "    " << "this->" << a->name->id << "->accept(\""<< a->name->id <<"\",visitor);" << endl;
    } else {
      out << "    " << "visitor.collectionPre();" << endl;
      out << "    " << "for (auto& item : " << a->name->id << ") {" << endl;
      out << "      " << "item->accept(\""<< a->name->id <<"\",visitor);"<<endl;
      out << "    " << "}"<<endl;
      out << "    " << "visitor.collectionPost();" << endl;
    }
  }
  out << "    " << "visitor.visitPost(name,*this);" << endl;
  out << "  " << "}" << endl;
  
  // Struct close
  out << "};" << endl << endl;
  
  // ostream operator
  out << "std::ostream& operator<< (std::ostream& out,const " << node.name->id << "& node) {" << endl;
  out << "  " << "out << \"(" << node.name->id << ": \";" << endl;
  for (auto& a : node.attributes) {      
    if (a->type->collection) {
      out << "  out << \"[\";" << endl;
      out << "  " << "for (auto& item : node." << a->name->id << ") {" << endl;
      out << "    " << "out << *item;" << endl;
      out << "  " << "}" << endl;
      out << "  out << \"]\";" << endl;
    } else {
      if (simpleType(a->type->id->id)) {
        out << "  " << "out << node." << a->name->id << ";" << endl;
      } else {
        out << "  " << "out << *node." << a->name->id << ";" << endl;
      }
    }
  }  
  out << "  " << "out << \")\";" << endl;
  out << "}" << endl << endl << endl;
}

struct CompileVisitor : public Visitor {
  void visitPost(const std::string& name,const Nodes& node) {
    auto& n=node.nodes;
    generateForwards(n); 
    generateVisitor(n); 
    for (auto& item : n) { 
      generate(*reinterpret_cast<Node*>(item.get())); 
    }
    generatePrettyPrintVisitor(n);
  }
};

%}

grammar = (- @n:astnode -)* !.              { $$ = make_unique<Nodes>(move(n)); }

id = <[a-zA-Z0-9_]+>                        { $$ = make_unique<Id>(yytext); }
type = ('[' - i:id - ']')                   { $$ = make_unique<Type>(move(i),true); }
     | i:id                                 { $$ = make_unique<Type>(move(i),false); }
attribute = - i:id - ':' - t:type -         { $$ = make_unique<Attribute>(move(i),move(t)); }
astnode = i:id -
          '(' - @a:attribute? 
          (-',' - @a:attribute - )*-')'     { $$ = make_unique<Node>(move(i),move(a)); }

-             = comment | space
space         = [ \t\r\n]*
comment       = space '--' ([^\r\n])* [\r\n]* space


%%

int main()
{
  GREG g;
  GREG *G=&g;
  
  out << "struct Visitor; struct Ast { virtual void can_dynamic_cast() {} virtual void accept(const std::string&,Visitor&)=0; };" << endl;
  out << "std::ostream& operator<< (std::ostream& out,const Ast& node) { out << \"(Ast)\"; }" << endl;
  out << "using std::string;" << endl << endl;

  yyinit(G);
  if (!yyparse(G)) {
    // Find current line
    uint64_t line=1;
    for (uint64_t index=0;index<G->maxPos;++index) if (G->buf[index]=='\n') ++line;
    
    // Find previous newline distance
    uint64_t col=1;
    for (uint64_t index=G->maxPos;index>0&&G->buf[index]!='\n';++col,--index);
    
    // Delimit text with \0 at first newline after error
    for (uint64_t index=G->maxPos;;++index) {
      if (index>=G->limit&&(G->pos=index,!yyrefill(G))) break;
      if (!G->buf[index] || G->buf[index]=='\r' || G->buf[index]=='\n') {
        G->buf[index]=0;
        break;
      }
    }

    // Report error
    cerr << "Line " << line << ", column " << col << " ";
    cerr << "Can not parse: \"" << &G->buf[G->maxPos] << "\"" << endl;
  }
  CompileVisitor c;
  G->ss->accept("root",c);
  PrettyPrintVisitor p;
  G->ss->accept("root",p);
  yydeinit(G);
  return 0;
}
