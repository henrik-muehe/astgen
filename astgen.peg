%{
#include <cstdio>
#include <iostream>
#include <ostream>
#include <memory>
#include <vector>
#include <string>

template<typename T, typename ...Args>
std::unique_ptr<T> make_unique( Args&& ...args )
{
    return std::unique_ptr<T>( new T( std::forward<Args>(args)... ) );
}

#include "ast.hpp"

using namespace std;

auto& out = cout;
#define YYSTYPE std::unique_ptr<Ast>
#define YY_CTYPE Collection
#define YY_CTYPE_DEFINITION() ;

static bool simpleType(std::string tn) {
  return (tn=="bool"||tn=="integer"||tn=="string"||tn=="int64_t");
}

void generateForwards(const std::vector<std::unique_ptr<Node>>& nodes) {
  cout << "// Forward declarations" << endl;
  for (auto& nodePtr : nodes) {
    Node& node=*reinterpret_cast<Node*>(nodePtr.get());    
    out << "struct "<<node.name->id<<";" << endl;
  }
  cout << endl;
}

void generateVisitor(const std::vector<std::unique_ptr<Node>>& nodes) {
  out << "// Visitor base class" << endl;
  out << "struct Visitor {" << endl;
  out << "  virtual void visitPre(const std::string& name,const Ast&) {}" << endl;
  out << "  virtual void visitPost(const std::string& name,const Ast&) {}" << endl;
  out << "  virtual void collectionPre() {}" << endl;
  out << "  virtual void collectionPost() {}" << endl;
  for (auto& nodePtr : nodes) {
    Node& node=*reinterpret_cast<Node*>(nodePtr.get());
    
    out << "  virtual void visitPre(const std::string& name,const "<<node.name->id<<"&) {}" << endl;
    out << "  virtual void visitPost(const std::string& name,const "<<node.name->id<<"&) {}" << endl;
  }
  out << "};" << endl << endl;
}

void generatePrettyPrintVisitor(const std::vector<std::unique_ptr<Node>>& nodes) {
  out << "// Pretty Print Visitor" << endl;
  out << "struct PrettyPrintVisitor : public Visitor {" << endl;
  out << "  std::stack<bool> doIndent;" << endl;
  out << "  void applyIndent(int64_t mod=0) { if (doIndent.top()) { std::cerr << std::string((doIndent.size()+mod)*2,' '); } }" << endl;
  out << "  void applyNl() { if (doIndent.top()) { std::cerr << std::endl; } }" << endl;
  out << "  PrettyPrintVisitor() { doIndent.push(false); }" << endl;
  out << "  void collectionPre() { applyIndent(); std::cerr << \"[\" << std::endl; doIndent.push(true); }" << endl;
  out << "  void collectionPost() { applyIndent(-1); doIndent.pop(); std::cerr << \"]\" << std::endl; }" << endl;
  for (auto& nodePtr : nodes) {
    Node& node=*reinterpret_cast<Node*>(nodePtr.get());
    
    out << "  virtual void visitPre(const std::string& name,const "<<node.name->id<<"& n) { applyIndent(); std::cerr << \"(\" << name << \":" << node.name->id <<" \"; doIndent.push(false); }" << endl;
    out << "  virtual void visitPost(const std::string& name,const "<<node.name->id<<"& n) { doIndent.pop(); applyIndent(); std::cerr << \")\"; applyNl(); }" << endl;
  }
  out << "};" << endl << endl;
}

void generate(Node& node) {
  // Struct
  out << "struct " << node.name->id << " : public Ast {" << endl;
  for (auto& a : node.attributes) {
    if (simpleType(a->type->id->id)) {
      out << "  " << a->type->id->id << " " << a->name->id << ";" << endl;
    } else if (a->type->collection) {
      out << "  std::vector<std::unique_ptr<" << a->type->id->id << ">> " << a->name->id << ";" << endl;
    } else {
      out << "  std::unique_ptr<" << a->type->id->id << "> " << a->name->id << ";" << endl;
    }
  }

  // Constructor signature
  out << endl;
  out << "  " << node.name->id << "(";
  bool first=true;
  for (auto& a : node.attributes) {      
    if (!first) out << ","; first=false;
    if (simpleType(a->type->id->id)) {
      out << "const "<< a->type->id->id << "& " << a->name->id;
    } else if (!a->type->collection) {
      out << "std::unique_ptr<Ast>&& " << a->name->id;
    } else {
      out << "std::unique_ptr<Ast>&& " << a->name->id;
    }
  }
  out << ") {" << endl;

  // Constructor body
  for (auto& a : node.attributes) {      
    if (simpleType(a->type->id->id)) {
      out << "    " << "this->" << a->name->id << "=" << a->name->id << ";" << endl;
    } else if (!a->type->collection) {
      out << "    " << "this->" << a->name->id << "=std::unique_ptr<" << a->type->id->id << ">(tryCast<" << a->type->id->id << "*>(" << a->name->id << ".get()));" << endl;
      out << "    " << a->name->id << ".release();" << endl;
      out << endl;
    } else {
      out << "    " << "if (" << a->name->id << ".get())" << endl;
      out << "    " << "for (auto& item : tryCast<Collection*>(" << a->name->id << ".get())->get()) {" << endl;
      out << "      " << "this->" << a->name->id << ".push_back(std::unique_ptr<"<< a->type->id->id <<">(tryCast<"<< a->type->id->id << "*>(item.get())));" << endl;
      out << "      " << "item.release();"<<endl;
      out << "    " << "}"<<endl;
    }
  }    
  out << "  }" << endl << endl;
  
  // Visitor accept
  out << "  " << "void accept(const std::string& name,Visitor& visitor) {" << endl;
  out << "    " << "visitor.visitPre(name,*this);" << endl;
  for (auto& a : node.attributes) {      
    if (simpleType(a->type->id->id)) {
      // We don't visit those right now
    } else if (!a->type->collection) {
      out << "    " << "this->" << a->name->id << "->accept(\""<< a->name->id <<"\",visitor);" << endl;
    } else {
      out << "    " << "visitor.collectionPre();" << endl;
      out << "    " << "for (auto& item : " << a->name->id << ") {" << endl;
      out << "      " << "item->accept(\""<< a->name->id <<"\",visitor);"<<endl;
      out << "    " << "}"<<endl;
      out << "    " << "visitor.collectionPost();" << endl;
    }
  }
  out << "    " << "visitor.visitPost(name,*this);" << endl;
  out << "  " << "}" << endl;
  
  // Struct close
  out << "};" << endl << endl;
  
  // ostream operator
  out << "std::ostream& operator<< (std::ostream& out,const " << node.name->id << "& node) {" << endl;
  out << "  " << "out << \"(" << node.name->id << ": \";" << endl;
  for (auto& a : node.attributes) {      
    if (a->type->collection) {
      out << "  out << \"[\";" << endl;
      out << "  " << "for (auto& item : node." << a->name->id << ") {" << endl;
      out << "    " << "out << *item;" << endl;
      out << "  " << "}" << endl;
      out << "  out << \"]\";" << endl;
    } else {
      if (simpleType(a->type->id->id)) {
        out << "  " << "out << node." << a->name->id << ";" << endl;
      } else {
        out << "  " << "out << *node." << a->name->id << ";" << endl;
      }
    }
  }  
  out << "  " << "out << \")\";" << endl;
  out << "}" << endl << endl << endl;
}

struct CompileVisitor : public Visitor {
  void visitPost(const std::string& name,const Nodes& node) {
    auto& n=node.nodes;

    out << "struct Visitor; struct Ast { virtual void can_dynamic_cast() {} virtual void accept(const std::string&,Visitor&)=0; };" << endl;
    out << "std::ostream& operator<< (std::ostream& out,const Ast& node) { out << \"(Ast)\"; }" << endl;
    out << "using std::string;" << endl << endl;
    out << "struct Collection : Ast {" <<endl;
    out << "  void accept(const string&, Visitor&) {};" << endl;
    out << "  std::vector<std::unique_ptr<Ast>> items; " << endl;
    out << "  void push_back(std::unique_ptr<Ast>&& item) { items.push_back(std::move(item)); } " << endl;
    out << "  std::vector<std::unique_ptr<Ast>>& get() { return items; }" << endl;
    out << "};" << endl << endl;
    out << "template<class T,class S>" << endl;
    out << "T tryCast(S s) {" << endl;
    out << "  T t=dynamic_cast<T>(s);" << endl;
    out << "  if (!t) {" << endl;
    out << "    std::cerr << \"AST type mismatch.\" << std::endl;" << endl;
    out << "    throw;" << endl;
    out << "  }" << endl;
    out << "  return t;" << endl;
    out << "}" << endl << endl;

    generateForwards(n); 
    generateVisitor(n); 
    for (auto& item : n) { 
      generate(*reinterpret_cast<Node*>(item.get())); 
    }
    generatePrettyPrintVisitor(n);
  }
};

%}

grammar = (- @n:astnode -)* !.              { $$ = make_unique<Nodes>(move(n)); }

id = <[a-zA-Z0-9_]+>                        { $$ = make_unique<Id>(yytext); }
type = ('[' - i:id - ']')                   { $$ = make_unique<Type>(move(i),true); }
     | i:id                                 { $$ = make_unique<Type>(move(i),false); }
attribute = - i:id - ':' - t:type -         { $$ = make_unique<Attribute>(move(i),move(t)); }
attribute_list = '(' - @a:attribute? - (',' - @a:attribute - )* - ')' { $$=move(a); }
astnode = i:id - a:attribute_list           { $$ = make_unique<Node>(move(i),move(a)); }

-             = comment | space
space         = [ \t\r\n]*
comment       = space '--' ([^\r\n])* [\r\n]* space


%%

int main()
{
  GREG g;
  GREG *G=&g;
  
  yyinit(G);
  if (!yyparse(G)) {
    // Find current line
    uint64_t line=1;
    for (uint64_t index=0;index<G->maxPos;++index) if (G->buf[index]=='\n') ++line;
    
    // Find previous newline distance
    uint64_t col=1;
    for (uint64_t index=G->maxPos;index>0&&G->buf[index]!='\n';++col,--index);
    
    // Delimit text with \0 at first newline after error
    for (uint64_t index=G->maxPos;;++index) {
      if (index>=G->limit&&(G->pos=index,!yyrefill(G))) break;
      if (!G->buf[index] || G->buf[index]=='\r' || G->buf[index]=='\n') {
        G->buf[index]=0;
        break;
      }
    }

    // Report error
    cerr << "Line " << line << ", column " << col << " ";
    cerr << "Can not parse: \"" << &G->buf[G->maxPos] << "\"" << endl;
  }

  CompileVisitor c;
  G->ss->accept("root",c);
  
  PrettyPrintVisitor p; G->ss->accept("root",p); cerr << endl;
  yydeinit(G);
  return 0;
}
