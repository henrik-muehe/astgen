/* A recursive-descent parser generated by greg 0.4.3 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <memory>
#include <vector>
#include <unordered_map>
#include <stack>
struct GREG;
#define YYRULECOUNT 9

#include <cstdio>
#include <iostream>
#include <ostream>
#include <memory>
#include <vector>
#include <string>
#include <ctemplate/template.h>

template<typename T, typename ...Args>
std::unique_ptr<T> make_unique( Args&& ...args )
{
    return std::unique_ptr<T>( new T( std::forward<Args>(args)... ) );
}

#include "ast.hpp"

using namespace std;

auto& out = cout;
#define YYSTYPE std::unique_ptr<Ast>
#define YY_CTYPE Collection
#define YY_CTYPE_DEFINITION() ;

static bool simpleType(std::string tn) {
  return (tn=="bool"||tn=="string"||tn=="int64_t");
}

void generateForwards(const std::vector<std::unique_ptr<Node>>& nodes) {
  cout << "// Forward declarations" << endl;
  for (auto& nodePtr : nodes) {
    Node& node=*reinterpret_cast<Node*>(nodePtr.get());    
    out << "struct "<<node.name->id<<";" << endl;
  }
  cout << endl;
}

void generateVisitor(const std::vector<std::unique_ptr<Node>>& nodes) {
  out << "// Visitor base class" << endl;
  out << "struct Visitor {" << endl;
  out << "  virtual void visitPre(const std::string& name,const Ast&) {}" << endl;
  out << "  virtual void visitPost(const std::string& name,const Ast&) {}" << endl;
  out << "  virtual void visitPre(const std::string& name,const Collection&) {}" << endl;
  out << "  virtual void visitPost(const std::string& name,const Collection&) {}" << endl;
  out << "  virtual void visit(const std::string& name,const int64_t&) {}" << endl;
  out << "  virtual void visit(const std::string& name,const std::string&) {}" << endl;
  out << "  virtual void collectionPre() {}" << endl;
  out << "  virtual void collectionPost() {}" << endl;
  for (auto& nodePtr : nodes) {
    Node& node=*reinterpret_cast<Node*>(nodePtr.get());
    
    out << "  virtual void visitPre(const std::string& name,const "<<node.name->id<<"&) {}" << endl;
    out << "  virtual void visitPost(const std::string& name,const "<<node.name->id<<"&) {}" << endl;
  }
  out << "};" << endl << endl;
}

static std::string rubyDefinitionTemplate = R"tpl(
{{#NODES}}	
class {{NODE_NAME}} < RenderStruct.new({{#ATTRS}}:{{ATTR_NAME}}{{#ATTRS_separator}},{{/ATTRS_separator}}{{/ATTRS}}); end
{{/NODES}}
)tpl"; //"

std::string generateRubyDefinition(const std::vector<std::unique_ptr<Node>>& nodes) {
  ctemplate::StringToTemplateCache("ast_ruby_def",rubyDefinitionTemplate.c_str(),ctemplate::STRIP_BLANK_LINES);
  
  ctemplate::TemplateDictionary dict("ruby def");
  for (auto& nodePtr : nodes) {
    Node& node=*reinterpret_cast<Node*>(nodePtr.get());
    
    auto nodeDict=dict.AddSectionDictionary("NODES");
    nodeDict->SetValue("NODE_NAME",node.name->id);

		if (node.attributes.empty()) {
	    auto attrDict=nodeDict->AddSectionDictionary("ATTRS");
	    attrDict->SetValue("ATTR_NAME","dummy");
		} else
		for (auto& attrPtr : node.attributes) {
	    Attribute& attr=*reinterpret_cast<Attribute*>(attrPtr.get());
	    auto attrDict=nodeDict->AddSectionDictionary("ATTRS");
	    attrDict->SetValue("ATTR_NAME",attr.name->id);
		}
  }
  
  string output;
  ctemplate::ExpandTemplate("ast_ruby_def",ctemplate::STRIP_BLANK_LINES,&dict,&output);
  return output;
}


static std::string rubyAstTemplate = R"tpl(
struct RubyAstVisitor : public Visitor {
	bool doComma;
   
   RubyAstVisitor() : doComma(false) {}
	
	std::string getDefinition() const {
		return R"(
			{{DEFINITION}}
		)";
	}
	
	void tryComma() {
		if (doComma) {
			std::cerr << "," << std::endl;
			doComma=false;
		}
	}
	
  void collectionPre() { 
		tryComma();
    std::cerr << "[";
		doComma=false;
  }
  
  void collectionPost() { 
    std::cerr << "]";
		doComma=true;
  }  
  
  {{#NODES}}
  virtual void visitPre(const std::string& name,const {{NODE_NAME}}& n) { 
		tryComma();
    std::cerr << "{{NODE_NAME}}.new(";
  }
  
  virtual void visitPost(const std::string& name,const {{NODE_NAME}}& n) { 
    std::cerr << ").line_col({{LINE}},{{COL}})";
		doComma=true;
  }  
  {{/NODES}}
  
  virtual void visit(const std::string& name,const int64_t& v) { tryComma(); std::cerr << v; }
  virtual void visit(const std::string& name,const std::string& v) { tryComma(); std::cerr << "\"" << v << "\""; }
};
)tpl"; //"

void generateRubyAstVisitor(const std::vector<std::unique_ptr<Node>>& nodes) {
	std::string def=generateRubyDefinition(nodes);
	ctemplate::StringToTemplateCache("ast_ruby_ast",rubyAstTemplate.c_str(),ctemplate::DO_NOT_STRIP);
  
  ctemplate::TemplateDictionary dict("ruby ast");
  dict.SetValue("DEFINITION",def);
	if (nodes.empty()) {
    auto nodeDict=dict.AddSectionDictionary("NODES");
    nodeDict->SetValue("NODE_NAME",":dummy");
	} else
  for (auto& nodePtr : nodes) {
    Node& node=*reinterpret_cast<Node*>(nodePtr.get());
    
    auto nodeDict=dict.AddSectionDictionary("NODES");
    nodeDict->SetValue("NODE_NAME",node.name->id);
    nodeDict->SetIntValue("LINE",node.line);
    nodeDict->SetIntValue("COL",node.col);
  }
  
  string output;
  ctemplate::ExpandTemplate("ast_ruby_ast",ctemplate::DO_NOT_STRIP,&dict,&output);
  out << output << endl;
}


static std::string prettyPrinterTemplate = R"tpl(
struct PrettyPrintVisitor : public Visitor {
  std::stack<bool> indentScopes;
  uint64_t indentDepth;
  
  void pushScope(bool indent=false) { indentScopes.push(indent); indentDepth+=indent; }
  void popScope() { indentDepth-=indentScopes.top(); indentScopes.pop(); }
  
  void applyIndent(int64_t mod=0) { 
    if (indentScopes.top()) { 
      std::cerr << std::string((indentDepth+mod)*2,' '); 
    } 
  }
  
  void applyNl() { 
    if (indentScopes.top()) 
      std::cerr << std::endl;
  }
  
  PrettyPrintVisitor() : indentDepth(0) { pushScope(); }
  
  void collectionPre() { 
    applyIndent();
    std::cerr << "[" << std::endl; 
    pushScope(true);
  }
  
  void collectionPost() { 
    applyIndent(-1); 
    popScope();
    std::cerr << "]";// << std::endl; 
  }  
  
  {{#NODE_VISITORS}}
  virtual void visitPre(const std::string& name,const {{NODE_NAME}}& n) { 
    applyIndent(); 
    std::cerr << "(" << "{{NODE_NAME}} " << name << "="; 
    pushScope();
  }
  
  virtual void visitPost(const std::string& name,const {{NODE_NAME}}& n) { 
    applyIndent();
    popScope();
    std::cerr << ")"; 
    applyNl(); 
  }  
  {{/NODE_VISITORS}}
  
  virtual void visit(const std::string& name,const int64_t& v) { std::cerr << "(" << name << "=" << "\"" << v << "\")"; }
  virtual void visit(const std::string& name,const std::string& v) { std::cerr << "(" << name << "=" << "\"" << v << "\")"; }
};
)tpl"; //"

void generatePrettyPrintVisitor(const std::vector<std::unique_ptr<Node>>& nodes) {
  ctemplate::StringToTemplateCache("ast_pretty_print",prettyPrinterTemplate.c_str(),ctemplate::DO_NOT_STRIP);
  
  ctemplate::TemplateDictionary dict("pretty printer");
  for (auto& nodePtr : nodes) {
    Node& node=*reinterpret_cast<Node*>(nodePtr.get());
    
    auto nodeDict=dict.AddSectionDictionary("NODE_VISITORS");
    nodeDict->SetValue("NODE_NAME",node.name->id);
  }
  
  string output;
  ctemplate::ExpandTemplate("ast_pretty_print",ctemplate::DO_NOT_STRIP,&dict,&output);
  out << output << endl;
}

void generate(Node& node) {
  // Struct
  out << "struct " << node.name->id << " : public Ast {" << endl;
  for (auto& a : node.attributes) {
    if (simpleType(a->type->id->id)) {
      out << "  " << a->type->id->id << " " << a->name->id << ";" << endl;
    } else if (a->type->collection) {
      out << "  std::vector<std::unique_ptr<" << a->type->id->id << ">> " << a->name->id << ";" << endl;
    } else {
      out << "  std::unique_ptr<" << a->type->id->id << "> " << a->name->id << ";" << endl;
    }
  }

  // Constructor signature
  out << endl;
  out << "  " << node.name->id << "(";
  bool first=true;
  for (auto& a : node.attributes) {      
    if (!first) out << ","; first=false;
    if (simpleType(a->type->id->id)) {
      out << "const "<< a->type->id->id << "& " << a->name->id;
    } else if (!a->type->collection) {
      out << "std::unique_ptr<Ast>&& " << a->name->id;
    } else {
      out << "std::unique_ptr<Ast>&& " << a->name->id;
    }
  }
  out << ") {" << endl;

  // Constructor body
  for (auto& a : node.attributes) {      
    if (simpleType(a->type->id->id)) {
      out << "    " << "this->" << a->name->id << "=" << a->name->id << ";" << endl;
    } else if (!a->type->collection) {
      out << "    " << "this->" << a->name->id << "=std::unique_ptr<" << a->type->id->id << ">(tryCast<" << a->type->id->id << "*>(" << a->name->id << ".get()));" << endl;
      out << "    " << a->name->id << ".release();" << endl;
      out << endl;
    } else {
      out << "    " << "if (" << a->name->id << ".get())" << endl;
      out << "    " << "for (auto& item : tryCast<Collection*>(" << a->name->id << ".get())->get()) {" << endl;
      out << "      " << "this->" << a->name->id << ".push_back(std::unique_ptr<"<< a->type->id->id <<">(tryCast<"<< a->type->id->id << "*>(item.get())));" << endl;
      out << "      " << "item.release();"<<endl;
      out << "    " << "}"<<endl;
    }
  }    
  out << "  }" << endl << endl;
  
  // Visitor accept
  out << "  " << "void accept(const std::string& name,Visitor& visitor) {" << endl;
  out << "    " << "visitor.visitPre(name,*this);" << endl;
  for (auto& a : node.attributes) {      
    if (simpleType(a->type->id->id)) {
      // We don't visit those right now
      out << "    " << "visitor.visit(\""<< a->name->id <<"\",this->" << a->name->id << ");" << endl;
    } else if (!a->type->collection) {
      out << "    " << "if (this->"<<a->name->id<<".get()) this->" << a->name->id << "->accept(\""<< a->name->id <<"\",visitor);" << endl;
    } else {
      out << "    " << "visitor.collectionPre();" << endl;
      out << "    " << "for (auto& item : " << a->name->id << ") {" << endl;
      out << "      " << "if (item.get()) item->accept(\""<< a->name->id <<"\",visitor);"<<endl;
      out << "    " << "}"<<endl;
      out << "    " << "visitor.collectionPost();" << endl;
    }
  }
  out << "    " << "visitor.visitPost(name,*this);" << endl;
  out << "  " << "}" << endl;
  
  // Struct close
  out << "};" << endl << endl;
  
  // ostream operator
  out << "std::ostream& operator<< (std::ostream& out,const " << node.name->id << "& node) {" << endl;
  out << "  " << "out << \"(" << node.name->id << ": \";" << endl;
  for (auto& a : node.attributes) {      
    if (a->type->collection) {
      out << "  out << \"[\";" << endl;
      out << "  " << "for (auto& item : node." << a->name->id << ") {" << endl;
      out << "    " << "out << *item;" << endl;
      out << "  " << "}" << endl;
      out << "  out << \"]\";" << endl;
    } else {
      if (simpleType(a->type->id->id)) {
        out << "  " << "out << node." << a->name->id << ";" << endl;
      } else {
        out << "  " << "out << *node." << a->name->id << ";" << endl;
      }
    }
  }  
  out << "  " << "out << \")\";" << endl;
  out << "}" << endl << endl << endl;
}

struct CompileVisitor : public Visitor {
  void visitPost(const std::string& name,const Nodes& node) {
    auto& n=node.nodes;

    out << "struct Visitor; struct Ast { int64_t line; int64_t col; virtual void can_dynamic_cast() {} virtual void accept(const std::string&,Visitor&)=0; };" << endl;
    out << "std::ostream& operator<< (std::ostream& out,const Ast& node) { out << \"(Ast)\"; }" << endl;
    out << "using std::string;" << endl << endl;
    out << "struct Collection : Ast {" <<endl;
    out << "  void accept(const string&, Visitor&) {};" << endl;
    out << "  std::vector<std::unique_ptr<Ast>> items; " << endl;
    out << "  void push_back(std::unique_ptr<Ast>&& item) { items.push_back(std::move(item)); } " << endl;
    out << "  std::vector<std::unique_ptr<Ast>>& get() { return items; }" << endl;
    out << "};" << endl << endl;
    out << "template<class T,class S>" << endl;
    out << "T tryCast(S s) {" << endl;
    out << "  if (!s) return 0;" << endl;
    out << "  T t=dynamic_cast<T>(s);" << endl;
    out << "  if (!t) {" << endl;
    out << "    std::cerr << \"AST type mismatch.\" << std::endl;" << endl;
    out << "    throw;" << endl;
    out << "  }" << endl;
    out << "  return t;" << endl;
    out << "}" << endl << endl;

    generateForwards(n); 
    generateVisitor(n); 
    for (auto& item : n) { 
      generate(*reinterpret_cast<Node*>(item.get())); 
    }
    generatePrettyPrintVisitor(n);
		generateRubyDefinition(n);
    generateRubyAstVisitor(n);
  }
};


#ifndef YY_ALLOC
#define YY_ALLOC(N, D) malloc(N)
#endif
#ifndef YY_CALLOC
#define YY_CALLOC(N, S, D) calloc(N, S)
#endif
#ifndef YY_REALLOC
#define YY_REALLOC(B, N, D) realloc(B, N)
#endif
#ifndef YY_FREE
#define YY_FREE free
#endif
#ifndef YY_LOCAL
#define YY_LOCAL(T)     static T
#endif
#ifndef YY_ACTION
#define YY_ACTION(T)    static T
#endif
#ifndef YY_RULE
#define YY_RULE(T)      static T
#endif
#ifndef YY_PARSE
#define YY_PARSE(T)     T
#endif
#ifndef YY_NAME
#define YY_NAME(N) yy##N
#endif
#ifndef YY_INPUT
#define YY_INPUT(buf, result, max_size, D,G)            \
  {                                                     \
    int yyc= getchar();                                 \
    if ('\n' == yyc || '\r' == yyc) { ++G->line; G->col=0; } else ++G->col;	      \
    result= (EOF == yyc) ? 0 : (*(buf)= yyc, 1);        \
    yyprintf((stderr, "<%c>", yyc));                  \
  }
#endif
#ifndef YY_BEGIN
#define YY_BEGIN        ( G->begin= G->pos, 1)
#endif
#ifndef YY_END
#define YY_END          ( G->end= G->pos, 1)
#endif
#ifdef YY_DEBUG
# define yyprintf(args) fprintf args
#else
# define yyprintf(args)
#endif
#ifndef YYSTYPE
#define YYSTYPE int
#endif
#ifndef YY_XTYPE
#define YY_XTYPE void *
#endif
#ifndef YY_XVAR
#define YY_XVAR yyxvar
#endif

#ifndef YY_STACK_SIZE
#define YY_STACK_SIZE 128
#endif

#ifndef YY_BUFFER_START_SIZE
#define YY_BUFFER_START_SIZE 1024
#endif

#ifndef YY_AST_TYPE
#define YY_AST_TYPE
#endif

#ifndef YY_CTYPE_DEFINITION 
#define YY_CTYPE_DEFINITION() \
  struct Collection YY_AST_TYPE { \
    std::vector<YYSTYPE> items; \
    void push_back(YYSTYPE&& item) { items.push_back(std::move(item)); } \
    operator std::vector<YYSTYPE>&() { return items; } \
  };
#endif

YY_CTYPE_DEFINITION()

#ifndef YY_CTYPE
#define YY_CTYPE Collection
#endif

#ifndef YY_PART
#define yydata G->data
#define yy G->ss

struct _yythunk; // forward declaration
typedef void (*yyaction)(GREG *G, char *yytext, int yyleng, struct _yythunk *thunkpos, YY_XTYPE YY_XVAR);
typedef struct _yythunk { int begin, end;  int line,col; yyaction  action;  struct _yythunk *next; } yythunk;

struct GREG {
  char *buf;
  int buflen;
  int   offset;
  int   pos;
  int   limit;
  char *text;
  int   textlen;
  int   begin;
  int   end;
  yythunk *thunks;
  int   thunkslen;
  int thunkpos;
  YYSTYPE ss;
  YYSTYPE *val;
  YYSTYPE *vals;
  int valslen;
  YY_XTYPE data;
  int maxPos;
  int line;
  int col;
  std::stack<std::unordered_map<int,std::unique_ptr<YY_CTYPE>>> collectionStack;
  GREG() : buf(0),buflen(0),offset(0),pos(0),limit(0),text(0),textlen(0),begin(0),end(0),thunks(0),thunkslen(0),thunkpos(0),val(0),vals(0),valslen(0),data(0),maxPos(0),line(0),col(0) {}
};

YY_LOCAL(int) yyrefill(GREG *G)
{
  int yyn;
  while (G->buflen - G->pos < 512)
    {
      G->buflen *= 2;
      G->buf= (char*)YY_REALLOC(G->buf, G->buflen, G->data);
    }
  YY_INPUT((G->buf + G->pos), yyn, (G->buflen - G->pos), G->data,G);
  if (!yyn) return 0;
  G->limit += yyn;
  return 1;
}

YY_LOCAL(int) yymatchDot(GREG *G)
{
  if (G->pos >= G->limit && !yyrefill(G)) return 0;
  ++G->pos;
  return 1;
}

YY_LOCAL(int) yymatchChar(GREG *G, int c)
{
  if (G->pos >= G->limit && !yyrefill(G)) return 0;
  if ((unsigned char)G->buf[G->pos] == c)
    {
      ++G->pos;
      yyprintf((stderr, "  ok   yymatchChar(%c) @ %s\n", c, G->buf+G->pos));
      return 1;
    }
  yyprintf((stderr, "  fail yymatchChar(%c) @ %s\n", c, G->buf+G->pos));
  return 0;
}

YY_LOCAL(int) yymatchString(GREG *G, const char *s)
{
  int yysav= G->pos;
  while (*s)
    {
      if (G->pos >= G->limit && !yyrefill(G)) return 0;
      if (G->buf[G->pos] != *s)
        {
          G->pos= yysav;
          return 0;
        }
      ++s;
      ++G->pos;
    }
  return 1;
}

YY_LOCAL(int) yymatchClass(GREG *G, unsigned char *bits)
{
  int c;
  if (G->pos >= G->limit && !yyrefill(G)) return 0;
  c= (unsigned char)G->buf[G->pos];
  if (bits[c >> 3] & (1 << (c & 7)))
    {
      ++G->pos;
      yyprintf((stderr, "  ok   yymatchClass @ %s\n", G->buf+G->pos));
      return 1;
    }
  yyprintf((stderr, "  fail yymatchClass @ %s\n", G->buf+G->pos));
  return 0;
}

YY_LOCAL(void) yyDo(GREG *G, yyaction action, int begin, int end)
{
  while (G->thunkpos >= G->thunkslen)
    {
      G->thunkslen *= 2;
      G->thunks= (yythunk*)YY_REALLOC(G->thunks, sizeof(yythunk) * G->thunkslen, G->data);
    }
  G->thunks[G->thunkpos].begin=  begin;
  G->thunks[G->thunkpos].end=    end;
  G->thunks[G->thunkpos].line=   G->line;
  G->thunks[G->thunkpos].col=    G->col;
  G->thunks[G->thunkpos].action= action;
  ++G->thunkpos;
}

YY_LOCAL(int) yyText(GREG *G, int begin, int end)
{
  int yyleng= end - begin;
  if (yyleng <= 0)
    yyleng= 0;
  else
    {
      while (G->textlen < (yyleng + 1))
        {
          G->textlen *= 2;
          G->text= (char*)YY_REALLOC(G->text, G->textlen, G->data);
        }
      memcpy(G->text, G->buf + begin, yyleng);
    }
  G->text[yyleng]= '\0';
  return yyleng;
}

YY_LOCAL(void) yyDone(GREG *G)
{
  int pos;
  for (pos= 0; pos < G->thunkpos; ++pos)
    {
      yythunk *thunk= &G->thunks[pos];
      int yyleng= thunk->end ? yyText(G, thunk->begin, thunk->end) : thunk->begin;
      yyprintf((stderr, "DO [%d] %p %s\n", pos, thunk->action, G->text));
      thunk->action(G, G->text, yyleng, thunk, G->data);
    }
  G->thunkpos= 0;
}

YY_LOCAL(void) yyCommit(GREG *G)
{
  if ((G->limit -= G->pos))
    {
      memmove(G->buf, G->buf + G->pos, G->limit);
    }
  G->offset += G->pos;
  G->begin -= G->pos;
  G->end -= G->pos;
  G->pos= G->thunkpos= 0;
}

YY_LOCAL(int) yyAccept(GREG *G, int tp0)
{
  if (tp0)
    {
      fprintf(stderr, "accept denied at %d\n", tp0);
      return 0;
    }
  else
    {
      yyDone(G);
      yyCommit(G);
    }
  return 1;
}

YY_LOCAL(void) yyPush(GREG *G, char *text, int count, yythunk *thunk, YY_XTYPE YY_XVAR) { while(count--) { new (&G->val[0]) YYSTYPE(); G->val++; } }
YY_LOCAL(void) yyPop(GREG *G, char *text, int count, yythunk *thunk, YY_XTYPE YY_XVAR)  { G->val -= count; }
YY_LOCAL(void) yySet(GREG *G, char *text, int count, yythunk *thunk, YY_XTYPE YY_XVAR)  { G->val[count]= std::move(G->ss); }
YY_LOCAL(void) yyResetSS(GREG *G, char *text, int count, yythunk *thunk, YY_XTYPE YY_XVAR)  { new (&G->ss) YYSTYPE(); }

YY_LOCAL(void) yyPushCollection(GREG *G, char *text, int count, yythunk *thunk, YY_XTYPE YY_XVAR) { G->collectionStack.push(std::unordered_map<int,std::unique_ptr<YY_CTYPE>>()); }
YY_LOCAL(void) yyPopCollection(GREG *G, char *text, int count, yythunk *thunk, YY_XTYPE YY_XVAR) { G->collectionStack.pop(); }
YY_LOCAL(void) yyAddToCollection(GREG *G, char *text, int count, yythunk *thunk, YY_XTYPE YY_XVAR) { if (!G->collectionStack.top()[count].get()) G->collectionStack.top()[count]=std::unique_ptr<YY_CTYPE>(new YY_CTYPE()); G->collectionStack.top()[count]->push_back(std::move(G->ss)); }


#endif /* YY_PART */

#define YYACCEPT        yyAccept(G, yythunkpos0)

YY_RULE(int) yy_space(GREG *G); /* 9 */
YY_RULE(int) yy_comment(GREG *G); /* 8 */
YY_RULE(int) yy_attribute_list(GREG *G); /* 7 */
YY_RULE(int) yy_attribute(GREG *G); /* 6 */
YY_RULE(int) yy_type(GREG *G); /* 5 */
YY_RULE(int) yy_id(GREG *G); /* 4 */
YY_RULE(int) yy_astnode(GREG *G); /* 3 */
YY_RULE(int) yy__(GREG *G); /* 2 */
YY_RULE(int) yy_grammar(GREG *G); /* 1 */

YY_ACTION(void) yy_1_astnode(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
#define a G->val[-1]
#define i G->val[-2]
  yyprintf((stderr, "do yy_1_astnode\n"));
   yy = make_unique<Node>(move(i),move(a)); ;
#undef a
#undef i
}
YY_ACTION(void) yy_1_attribute_list(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
#define a (G->collectionStack.top()[-1])
  yyprintf((stderr, "do yy_1_attribute_list\n"));
   yy=move(a); ;
#undef a
}
YY_ACTION(void) yy_1_attribute(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
#define t G->val[-1]
#define i G->val[-2]
  yyprintf((stderr, "do yy_1_attribute\n"));
   yy = make_unique<Attribute>(move(i),move(t)); ;
#undef t
#undef i
}
YY_ACTION(void) yy_2_type(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
#define i G->val[-1]
  yyprintf((stderr, "do yy_2_type\n"));
   yy = make_unique<Type>(move(i),false); ;
#undef i
}
YY_ACTION(void) yy_1_type(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
#define i G->val[-1]
  yyprintf((stderr, "do yy_1_type\n"));
   yy = make_unique<Type>(move(i),true); ;
#undef i
}
YY_ACTION(void) yy_1_id(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
  yyprintf((stderr, "do yy_1_id\n"));
   yy = make_unique<Id>(yytext); ;
}
YY_ACTION(void) yy_1_grammar(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
#define n (G->collectionStack.top()[-1])
  yyprintf((stderr, "do yy_1_grammar\n"));
   yy = make_unique<Nodes>(move(n)); ;
#undef n
}

YY_RULE(int) yy_space(GREG *G)
{
  yyprintf((stderr, "%s\n", "space"));
  l2:;	
  {  G->maxPos=G->maxPos>G->pos?G->maxPos:G->pos; int yypos3= G->pos, yythunkpos3= G->thunkpos;  if (!yymatchClass(G, (unsigned char *)"\000\046\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l3;  goto l2;
  l3:;	  G->pos= yypos3; G->thunkpos= yythunkpos3;
  }
  yyprintf((stderr, "  ok   %s @ %s\n", "space", G->buf+G->pos));
  return 1;
}
YY_RULE(int) yy_comment(GREG *G)
{  G->maxPos=G->maxPos>G->pos?G->maxPos:G->pos; int yypos0= G->pos, yythunkpos0= G->thunkpos;
  yyprintf((stderr, "%s\n", "comment")); if (!yy_space(G)) { goto l4; }  if (!yymatchString(G, "--")) goto l4;
  l5:;	
  {  G->maxPos=G->maxPos>G->pos?G->maxPos:G->pos; int yypos6= G->pos, yythunkpos6= G->thunkpos;  if (!yymatchClass(G, (unsigned char *)"\377\333\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377")) goto l6;  goto l5;
  l6:;	  G->pos= yypos6; G->thunkpos= yythunkpos6;
  }
  l7:;	
  {  G->maxPos=G->maxPos>G->pos?G->maxPos:G->pos; int yypos8= G->pos, yythunkpos8= G->thunkpos;  if (!yymatchClass(G, (unsigned char *)"\000\044\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l8;  goto l7;
  l8:;	  G->pos= yypos8; G->thunkpos= yythunkpos8;
  } if (!yy_space(G)) { goto l4; }
  yyprintf((stderr, "  ok   %s @ %s\n", "comment", G->buf+G->pos));
  return 1;
  l4:;	  G->pos= yypos0; G->thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "comment", G->buf+G->pos));
  return 0;
}
YY_RULE(int) yy_attribute_list(GREG *G)
{  G->maxPos=G->maxPos>G->pos?G->maxPos:G->pos; int yypos0= G->pos, yythunkpos0= G->thunkpos;  yyDo(G, yyPushCollection, 0, 0);  yyDo(G, yyPush, 1, 0);
  yyprintf((stderr, "%s\n", "attribute_list"));  if (!yymatchChar(G, '(')) goto l9; if (!yy__(G)) { goto l9; }
  {  G->maxPos=G->maxPos>G->pos?G->maxPos:G->pos; int yypos10= G->pos, yythunkpos10= G->thunkpos; yyDo(G,yyResetSS,0,0);  if (!yy_attribute(G)) { goto l10; }  yyDo(G, yyAddToCollection, -1, 0);  goto l11;
  l10:;	  G->pos= yypos10; G->thunkpos= yythunkpos10;
  }
  l11:;	 if (!yy__(G)) { goto l9; }
  l12:;	
  {  G->maxPos=G->maxPos>G->pos?G->maxPos:G->pos; int yypos13= G->pos, yythunkpos13= G->thunkpos;  if (!yymatchChar(G, ',')) goto l13; if (!yy__(G)) { goto l13; } yyDo(G,yyResetSS,0,0);  if (!yy_attribute(G)) { goto l13; }  yyDo(G, yyAddToCollection, -1, 0); if (!yy__(G)) { goto l13; }  goto l12;
  l13:;	  G->pos= yypos13; G->thunkpos= yythunkpos13;
  } if (!yy__(G)) { goto l9; }  if (!yymatchChar(G, ')')) goto l9;  yyDo(G, yy_1_attribute_list, G->begin, G->end);
  yyprintf((stderr, "  ok   %s @ %s\n", "attribute_list", G->buf+G->pos));  yyDo(G, yyPop, 1, 0);  yyDo(G, yyPopCollection, 0, 0);
  return 1;
  l9:;	  G->pos= yypos0; G->thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "attribute_list", G->buf+G->pos));
  return 0;
}
YY_RULE(int) yy_attribute(GREG *G)
{  G->maxPos=G->maxPos>G->pos?G->maxPos:G->pos; int yypos0= G->pos, yythunkpos0= G->thunkpos;  yyDo(G, yyPush, 2, 0);
  yyprintf((stderr, "%s\n", "attribute")); if (!yy__(G)) { goto l14; } yyDo(G,yyResetSS,0,0);   yyDo(G, yySet, -2, 0); if (!yy_id(G)) { goto l14; }  yyDo(G, yySet, -2, 0); if (!yy__(G)) { goto l14; }  if (!yymatchChar(G, ':')) goto l14; if (!yy__(G)) { goto l14; } yyDo(G,yyResetSS,0,0);   yyDo(G, yySet, -1, 0); if (!yy_type(G)) { goto l14; }  yyDo(G, yySet, -1, 0); if (!yy__(G)) { goto l14; }  yyDo(G, yy_1_attribute, G->begin, G->end);
  yyprintf((stderr, "  ok   %s @ %s\n", "attribute", G->buf+G->pos));  yyDo(G, yyPop, 2, 0);
  return 1;
  l14:;	  G->pos= yypos0; G->thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "attribute", G->buf+G->pos));
  return 0;
}
YY_RULE(int) yy_type(GREG *G)
{  G->maxPos=G->maxPos>G->pos?G->maxPos:G->pos; int yypos0= G->pos, yythunkpos0= G->thunkpos;  yyDo(G, yyPush, 1, 0);
  yyprintf((stderr, "%s\n", "type"));
  {  G->maxPos=G->maxPos>G->pos?G->maxPos:G->pos; int yypos16= G->pos, yythunkpos16= G->thunkpos;  if (!yymatchChar(G, '[')) goto l17; if (!yy__(G)) { goto l17; } yyDo(G,yyResetSS,0,0);   yyDo(G, yySet, -1, 0); if (!yy_id(G)) { goto l17; }  yyDo(G, yySet, -1, 0); if (!yy__(G)) { goto l17; }  if (!yymatchChar(G, ']')) goto l17;  yyDo(G, yy_1_type, G->begin, G->end);  goto l16;
  l17:;	  G->pos= yypos16; G->thunkpos= yythunkpos16; yyDo(G,yyResetSS,0,0);   yyDo(G, yySet, -1, 0); if (!yy_id(G)) { goto l15; }  yyDo(G, yySet, -1, 0);  yyDo(G, yy_2_type, G->begin, G->end);
  }
  l16:;	
  yyprintf((stderr, "  ok   %s @ %s\n", "type", G->buf+G->pos));  yyDo(G, yyPop, 1, 0);
  return 1;
  l15:;	  G->pos= yypos0; G->thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "type", G->buf+G->pos));
  return 0;
}
YY_RULE(int) yy_id(GREG *G)
{  G->maxPos=G->maxPos>G->pos?G->maxPos:G->pos; int yypos0= G->pos, yythunkpos0= G->thunkpos;
  yyprintf((stderr, "%s\n", "id"));  yyText(G, G->begin, G->end);  if (!(YY_BEGIN)) goto l18;  if (!yymatchClass(G, (unsigned char *)"\000\000\000\000\000\000\377\003\376\377\377\207\376\377\377\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l18;
  l19:;	
  {  G->maxPos=G->maxPos>G->pos?G->maxPos:G->pos; int yypos20= G->pos, yythunkpos20= G->thunkpos;  if (!yymatchClass(G, (unsigned char *)"\000\000\000\000\000\000\377\003\376\377\377\207\376\377\377\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000")) goto l20;  goto l19;
  l20:;	  G->pos= yypos20; G->thunkpos= yythunkpos20;
  }  yyText(G, G->begin, G->end);  if (!(YY_END)) goto l18;  yyDo(G, yy_1_id, G->begin, G->end);
  yyprintf((stderr, "  ok   %s @ %s\n", "id", G->buf+G->pos));
  return 1;
  l18:;	  G->pos= yypos0; G->thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "id", G->buf+G->pos));
  return 0;
}
YY_RULE(int) yy_astnode(GREG *G)
{  G->maxPos=G->maxPos>G->pos?G->maxPos:G->pos; int yypos0= G->pos, yythunkpos0= G->thunkpos;  yyDo(G, yyPush, 2, 0);
  yyprintf((stderr, "%s\n", "astnode")); yyDo(G,yyResetSS,0,0);   yyDo(G, yySet, -2, 0); if (!yy_id(G)) { goto l21; }  yyDo(G, yySet, -2, 0); if (!yy__(G)) { goto l21; } yyDo(G,yyResetSS,0,0);   yyDo(G, yySet, -1, 0); if (!yy_attribute_list(G)) { goto l21; }  yyDo(G, yySet, -1, 0);  yyDo(G, yy_1_astnode, G->begin, G->end);
  yyprintf((stderr, "  ok   %s @ %s\n", "astnode", G->buf+G->pos));  yyDo(G, yyPop, 2, 0);
  return 1;
  l21:;	  G->pos= yypos0; G->thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "astnode", G->buf+G->pos));
  return 0;
}
YY_RULE(int) yy__(GREG *G)
{  G->maxPos=G->maxPos>G->pos?G->maxPos:G->pos; int yypos0= G->pos, yythunkpos0= G->thunkpos;
  yyprintf((stderr, "%s\n", "_"));
  {  G->maxPos=G->maxPos>G->pos?G->maxPos:G->pos; int yypos23= G->pos, yythunkpos23= G->thunkpos; if (!yy_comment(G)) { goto l24; }  goto l23;
  l24:;	  G->pos= yypos23; G->thunkpos= yythunkpos23; if (!yy_space(G)) { goto l22; }
  }
  l23:;	
  yyprintf((stderr, "  ok   %s @ %s\n", "_", G->buf+G->pos));
  return 1;
  l22:;	  G->pos= yypos0; G->thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "_", G->buf+G->pos));
  return 0;
}
YY_RULE(int) yy_grammar(GREG *G)
{  G->maxPos=G->maxPos>G->pos?G->maxPos:G->pos; int yypos0= G->pos, yythunkpos0= G->thunkpos;  yyDo(G, yyPushCollection, 0, 0);  yyDo(G, yyPush, 1, 0);
  yyprintf((stderr, "%s\n", "grammar"));
  l26:;	
  {  G->maxPos=G->maxPos>G->pos?G->maxPos:G->pos; int yypos27= G->pos, yythunkpos27= G->thunkpos; if (!yy__(G)) { goto l27; } yyDo(G,yyResetSS,0,0);  if (!yy_astnode(G)) { goto l27; }  yyDo(G, yyAddToCollection, -1, 0); if (!yy__(G)) { goto l27; }  goto l26;
  l27:;	  G->pos= yypos27; G->thunkpos= yythunkpos27;
  }
  {  G->maxPos=G->maxPos>G->pos?G->maxPos:G->pos; int yypos28= G->pos, yythunkpos28= G->thunkpos;  if (!yymatchDot(G)) goto l28;  goto l25;
  l28:;	  G->pos= yypos28; G->thunkpos= yythunkpos28;
  }  yyDo(G, yy_1_grammar, G->begin, G->end);
  yyprintf((stderr, "  ok   %s @ %s\n", "grammar", G->buf+G->pos));  yyDo(G, yyPop, 1, 0);  yyDo(G, yyPopCollection, 0, 0);
  return 1;
  l25:;	  G->pos= yypos0; G->thunkpos= yythunkpos0;
  yyprintf((stderr, "  fail %s @ %s\n", "grammar", G->buf+G->pos));
  return 0;
}

#ifndef YY_PART

typedef int (*yyrule)(GREG *G);

YY_PARSE(int) YY_NAME(parse_from)(GREG *G, yyrule yystart)
{
  int yyok;
  if (!G->buflen)
    {
      G->buflen= YY_BUFFER_START_SIZE;
      G->buf= (char*)YY_ALLOC(G->buflen, G->data);
      G->textlen= YY_BUFFER_START_SIZE;
      G->text= (char*)YY_ALLOC(G->textlen, G->data);
      G->thunkslen= YY_STACK_SIZE;
      G->thunks= (yythunk*)YY_ALLOC(sizeof(yythunk) * G->thunkslen, G->data);
      G->valslen= YY_STACK_SIZE;
      G->vals= (YYSTYPE*)YY_ALLOC(sizeof(YYSTYPE) * G->valslen, G->data);
      G->begin= G->end= G->pos= G->limit= G->thunkpos= 0;
    }
  G->pos = 0;
  G->begin= G->end= G->pos;
  G->thunkpos= 0;
  G->val= G->vals;
  yyok= yystart(G);
  if (yyok) yyDone(G);
  yyCommit(G);
  return yyok;
  (void)yyrefill;
  (void)yymatchDot;
  (void)yymatchChar;
  (void)yymatchString;
  (void)yymatchClass;
  (void)yyDo;
  (void)yyText;
  (void)yyDone;
  (void)yyCommit;
  (void)yyAccept;
  (void)yyPush;
  (void)yyPop;
  (void)yySet;
}

YY_PARSE(int) YY_NAME(parse)(GREG *G)
{
  return YY_NAME(parse_from)(G, yy_grammar);
}

YY_PARSE(void) YY_NAME(init)(GREG *G)
{
    //memset(G, 0, sizeof(GREG));
}
YY_PARSE(void) YY_NAME(deinit)(GREG *G)
{
    if (G->buf) YY_FREE(G->buf);
    if (G->text) YY_FREE(G->text);
    if (G->thunks) YY_FREE(G->thunks);
    if (G->vals) YY_FREE(G->vals);
}
YY_PARSE(GREG *) YY_NAME(parse_new)(YY_XTYPE data)
{
  GREG *G = (GREG *)YY_CALLOC(1, sizeof(GREG), G->data);
  G->data = data;
  return G;
}

YY_PARSE(void) YY_NAME(parse_free)(GREG *G)
{
  YY_NAME(deinit)(G);
  YY_FREE(G);
}

#endif


int main()
{
  GREG g;
  GREG *G=&g;
  
  yyinit(G);
  if (!yyparse(G)) {
    // Find current line
    uint64_t line=1;
    for (uint64_t index=0;index<G->maxPos;++index) if (G->buf[index]=='\n') ++line;
    
    // Find previous newline distance
    uint64_t col=1;
    for (uint64_t index=G->maxPos;index>0&&G->buf[index]!='\n';++col,--index);
    
    // Delimit text with \0 at first newline after error
    for (uint64_t index=G->maxPos;;++index) {
      if (index>=G->limit&&(G->pos=index,!yyrefill(G))) break;
      if (!G->buf[index] || G->buf[index]=='\r' || G->buf[index]=='\n') {
        G->buf[index]=0;
        break;
      }
    }

    // Report error
    cerr << "Line " << line << ", column " << col << " ";
    cerr << "Can not parse: \"" << &G->buf[G->maxPos] << "\"" << endl;
  }

  CompileVisitor c;
  G->ss->accept("root",c);
  
  //PrettyPrintVisitor p; G->ss->accept("root",p); cerr << endl << endl << endl;
	
  //RubyAstVisitor r; G->ss->accept("root",r); cerr << endl << endl << endl;
  yydeinit(G);
  return 0;
}

